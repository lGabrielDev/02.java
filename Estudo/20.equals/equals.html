<!--
equals() vs. == 

== 
Usado para comparar tipos primitivos
-Crie 2 variables
-Imprima se as duas variables são iguais:
    int number1 = 40;
    int number2 = 40;

    if(number1 == number2){
        System.out.println("São iguais");
    }
    else{
        System.out.println("São diferentes");
    }

TRUE

------------------------------------------------------------------------------------------------------------------------------------------

equals() 
Usado para comparar Strings.
-Crie 2 variables String com o mesmo valor

    String texto1 = new String("alface");
    String texto2 = new String("alface");

Como "String" é uma class e não um tipo primitivo, eu vou instanciar um novo objeto com o "new String".

-Compare usando o "=="
    System.out.println(texto1 == texto2);

FALSE

-Compare usando o ".equals()"
    System.out.println(texto1.equals(texto2));
TRUE



Resumindo:

==         -> Usado para comparar tipos primitivos;
.equals(); -> Usado para comparar Objects;

------------------------------------------------------------------------------------------------------------------------------

E se voce comparar 2 objetos de uma classe que voce criou??

-Crie uma class "Cachorro";
-Crie 1 atributo "nome";
-Crie 1 constructor
-Crie 2 objetos com o mesmo valor no programa main e compare esses dois objetos
    Cachorro c1 = new Cachorro("Jake");
    Cachorro c2 = new Cachorro("Jake");

    System.out.println(c1.equals(c2));

FALSE

Assim funcionaria:
    System.out.println(c1.getNome().equals(c2.getNome()));

Mas, vamos melhorar:

Isso acontece, porque quando eu uso ".equals()", eu estou comparando se os dois objetos estão ocupando o mesmo espaco na memória.

Cada objeto ocupa um espaco diferente da memoria. Então, o resultado vai ser sempre FALSE;

Para eu resolver, eu preciso SOBREESCREVER o method ".equals();"

Esse method vêm lá da Class "Object"

Toda classe do java é filha da class Object. Por isso que conseguimos usar o method ".equals();"

Basicamente, o method ".equals();" compara se eles tem a mesma localizacao na memoria.

Por padrao a resposta sempre será FALSE;

Eu posso modificar esse atributo, e definir o atributo que será comparado.



Vamos lá!!

-Crie uma class "Pessoa" com 2 atributos:
    String nome;
    int age;

-Crie 2 objetos com o mesmo valor no method main.
-Compare os dois objetos:
    System.out.println(p1.equals(p2));
    FALSE

Vamos resolver:


Pronto. Temos nossa class. Como toda classe é filho da class "Object", eu vou SOBREESCREVER o method equals:

-Crie um method equals:
    public boolean equals(Object objetoComparado){
        return
    }

Perceba que eu criei um method que vai retornar um valor boolean.
Perceba que eu criei um parametro "objetoComparado", que vai ser o objeto de comparacao.

Lembra... object1.equals(object2);
TRUE ou FALSE;
Esse "objetoComparado" seria o "object2"; Sacou??
Eu vou comparar o objeto atual com esse parametro.




-Crie uma variable que vai receber esse parametro.
    public boolean equals(Object obj){
        Pessoa p1 = (Pessoa) obj;
        return true;
    }

Perceba que eu crio uma variable que vai receber o objeto de comparacao. E eu estou transformando esse obj do tipo "Objeto" para o tipo "Pessoa";

Se eu colocasse apenas:
    Pessoa p1 = obj;
Ia dar ruim, porque são objetos de tipos dados diferentes. Por isso que eu preciso transformar os dois no mesmo tipo de objeto.
    Pessoa p1 = (Pessoa) obj;


Então, a minha variable "p1" vai receber o parametro, que é um  objeto, do tipo "Pessoa".


-Crie um if para comparar o atributo do objeto atual com o do parametro:

    public boolean equals(Object obj){
        Pessoa p1 = (Pessoa) obj;
        
        if(this.nome.equals(p1.nome))){
            return true;
        }
        return false;
    }

-Eu criei uma variable "p1" para receber o objeto parametro de comparacao.
-Criei um if para comparar o atributo "nome";
    Se o atributo "nome" do objeto atual for igual ao atributo "nome" do parametro, eu retorno true;
    Caso contrário, se eles tiverem valores diferentes, eu retorno false;
Pronto.


Crie 2 objetos no method main com os mesmos valores e imprima a comparacao:
    System.out.println(p1.equals(p2));


VOALÁ! EASY!





E se eu quisesse dizer que, dois objetos só vão ser iguais se a idade for igual.
Os objetos podem ter o mesmo nome, mas serão considerado objetos diferentes.
O atributo que vamos comparar é a idade:

    public boolean equals(Object obj){
        Pessoa p = (Pessoa) obj;

        if(this.age != p.age){
            return false;
        }
        else{
            return true;
        }
    }

Se o atributo idade do objeto atual for diferente do atributo idade do objeto parametro, retorna false;
Caso contrário, são objetos iguais;




E se eu quisesse que, dois objetos só vão ser iguais se todos os atributos forem iguais:

Fácil. É só usar o operador lógico &&:

    public boolean equals(Object obj){
        Pessoa p = (Pessoa) obj;

        if(this.nome.equals(p.nome) && this.age == p.age){
            return true;
        }
        else{
            return false;
        }

        
Só vao ser objetos iguais, se as duas condicoes forem atendidas;

-->
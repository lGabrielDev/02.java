<!--
polymorphism
Várias formas de fazer...
Eu crio o mesmo method de formas diferentes.

No polimorfismo eu tenho 2 tipos:

1-@Override (Sobreescrita)   -> Possui os mesmos parâmetros e uso em classes diferentes
2-Overload  (Sobrecarga)     -> Possui parâmetros diferentes e uso na mesma class

------------------------------------------------------------------------------------------------------------------------------------------

1- @Override

Quando eu tenho classes quem tem relação de herança eu posso ter atributos e methods com valores diferentes.


Exemplo:

Class Animal
Class Cachorro extends Animal

Imagina que eu crie um method para a Class Animal:

public void emitirSom(){
    System.out.println("Som de animal");
}


E crie o mesmo method com o @Override para a Class Cachorro

@Override
public void emitirSom(){
    System.out.println("AU! AU! AU!);
}


Se eu criar um objeto da Class Cachorro, o som que vai retornar vai ser o do cachorro.


Agora...Se EU NÃO criasse o method do som do cachorro, e criasse um objeto cachorro, o som que ia retornar seria o do animal.

Viu?? Poderia ser retornado valores diferentes.

Com atributos é a mesma coisa.


1- Crie o exemplo acima.
-Crie a Class Cachorro sem method > crie o objeto Cachorro > Chame o method
-Agora, coloque o methods @Override na Class Cachorro > Crie o objeto Cachorro > Chame o method


Viu??




Como boa prática, sempre é bom colocar o @Override para identificar que aquele method está sendo SOBREESCRITO.
Mas se eu não colocar, também funciona.
------------------------------------------------------------------------------------------------------------------------------------------
2- Overloading(Sobrecarga)
Eu posso criar methods com o mesmo nome desde que eles tenham parâmetros diferentes.

Aí, quando eu chamar o method, o que vai aparecer vai depender do parametro que eu digitar.

Igual no constructor... Eu posso criar vários constructors, desde que eles tenham parametros diferentes.


Como vimos antes, o polimorfismo do tipo @Override eu preciso ter herança e crio o mesmo method em classes diferentes com os mesmos parâmetro.

Com o polimorfismo do tipo sobrecarga, eu crio os methods na mesma class com parâmetros diferentes.



-Crie uma class Cachorro
-Crie 1 method mensagem e duplique ela com polimorfismo

public void mensagem(String parametro){
    System.out.println("Mensagem 1");
}

public void mensagem(Integer parametro){
    System.out.println("Mensagem 2");
}

public void mensagem(String parametro, String parametro2){
    System.out.println("Mensagem 3");
}

public void mensagem(String parametro1, int parametro3){
    System.out.println("Mensagem 4");
}

public void mensagem(int parametro1, String parametro3){
    System.out.println("Mensagem 5");
}

Perceba que eu tenho 5 methods com o mesmo nome. Porém, com parametros diferentes.
-Crie um objeto da Class Cachorro e chame o method.

Qual das mensagens vai vir??
Depende do parametro que eu colocar. Sacou??

-Dê ctrl+space e observe.... Viu?? Depende do parametro que eu colocar.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
(IMPORTANTE)

Criando uma array de objetos diferentes

1- Crie uma abstract class "Veiculo"; Ela vai ser a class pai;
    -Crie um method "acelerando"

        public abstract void acelerando();

Não precisar especificar o corpo. Nas classes filhas voce faz isso.


2- Crie 3 subclass(classes filhas) que vao herdar da class pai "Veiculo"
        "Aviao" extends Veiculo
        "Carro" extends Veiculo
        "Moto" extends Veiculo

3- Sobreescreva o method pai nos seus filhos    
    @Override
    public void acelerando(){
        System.out.println("Aviao está acelerando no céu!");
    }

    -Faça com as outras 2 classes "Carro" e "Moto"


Beleza. Tenho minhas subClasses criadas.

4- Crie um objeto de cada class:
    Carro c1 = new Carro();
    Moto m1 = new Moto();
    Aviao a1 = new Aviao();

    c1.acelerando();
    m1.acelerando();
    a1.acelerando();



5- E se eu quisesse criar uma array(vetor) desses objetos...

Se eu tentar criar uma array do tipo "Carro", só vai dar pra colocar objetos do tipo "Carro"...
Se eu tentar criar uma array do tipo "Moto", só vai dar pra colocar objetos do tipo "Moto"...
Se eu tentar criar uma array do tipo "Aviao", só vai dar pra colocar objetos do tipo "Aviao"...



Como são objetos diferentes, eu vou criar uma array do tipo que eles têm em comum...


Um "Aviao" é um "Veiculo";
Um "Carro" é um "Veiculo";
Um "Moto" é um "Veiculo";



Sacou?? Por isso eu crio uma class pai "genérica";

Então, vou criar uma array do tipo Veiculo:
    Veiculo[] listaVeiculos = {c1,m1,a1};

-Imprima o method "acelerando" de cada item
    for(Veiculo i : listaVeiculos){
        i.acelerando();
    }

Easy!

Resumindo...
Polymorphism -> A habilidade de um objeto se identificar de varias formas.


O objeto do tipo "Carro" é tanto um "Carro" quanto "Veiculo" quanto um "Object". Ele é considerado os 3 tipos. Sacou??

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
(Apenas leia)
dynamic polymorphism


Quando uma class é filha de outra, eu posso criar um objeto da classe pai e instanciar a class filha.


-Crie 1 SuperClass(pai)
    "Animal"
-Crie 2 subClasses
    "Dog" extends "Animal"
    "Cat" extends "Animal"

-Declare um objeto da class "Animal";
Ao invés de criar um objeto animal..
    Animal a1 = new Animal();

Eu posso criar um objeto especifico do tipo Animal
    Animal a1 = new Dog();
    Animal a2 = new Cat();

Viu??

"Dog" é um "Animal"... Por isso, eu posso instanciar diretamente a class filha.


"Cat" extends "Animal"... Por isso, eu posso instanciar diretamente a class filha.


Se eu fizesse assim:
    Dog a1 = new Dog();
    Cat a2 = new Cat();

    Daria no mesmo também.




Isso é interessante porque eu posso declarar meu objeto.
    Animal a1;
E só depois atribuir um valor:
    Animal a1 = new Dog();    OU
    Animal a1 = new Cat();





Dá pra utilizar em várias situacoes.
Quando perguntamos ao usuario se ele é boy or girl.... Dependendo do que ele escolher, criamos tal objeto. Sacou?
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
(IMPORTANTE)
Voce pode declarar um objeto e só depois instanciar o tipo desse objeto.

Vamos criar um programinha onde o usuario vai escolher entre 2 classes ("Dog" and "Cat"). Uma vez escolhido, vai imprimir na tela o barulho do animal escolhido.


1- Crie 1 class pai
    "Animal"

-Crie um method na class "Animal". Não precisa especificar o que esse method vai fazer.

    public class Animal {
        public void sound(){
    };
}



2- Crie 2 classes que vao extends a class pai "Animal"
    "Dog" extends "Animal"
    "Cat" extends "Animal"

- Sobreescreva o method do pai:
    @Override
    public void sound(){
        System.out.println("Dog goes *BARK*!");
    };



    -Faça a mesma coisa para class "Cat";
        public void sound(){
            System.out.println("Cat goes MEOW!");
        };


3- No method main, apenas declare um objeto do tipo Animal.
    Animal a1;

É igual quando voce declara uma String,int,double,etc... Sem declarar um valor;
    String texto;
    int number1;

Sacou?

4- Crie um objeto Scanner:
        Animal a1;



    Animal a1;
        Integer opcaoEscolhida = 0;
        Boolean inputCorreto = false;

        Scanner scan = new Scanner(System.in);
        do{
            try{
                System.out.println("\n\nEscolha um animal:\n1- Dog\n2- Cat");
                opcaoEscolhida = scan.nextInt();
                inputCorreto = true;

                switch(opcaoEscolhida){
                    case 1:
                        a1 = new Dog();
                        System.out.println(a1.emitirSom());
                        break;
                    case 2:
                        a1 = new Cat();
                        System.out.println(a1.emitirSom());
                        break;
                    default:
                        System.out.println("Opcao inválida.");
                }
            }
            catch(InputMismatchException e){
                System.out.println("Erro! Por favor, digite um número.");
                inputCorreto = false;
                scan.nextLine();
            }    
        }
        while(!(inputCorreto) || opcaoEscolhida <= 0 || opcaoEscolhida > 2);
        scan.close();

(Upar no git esse exemplo depois)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-->